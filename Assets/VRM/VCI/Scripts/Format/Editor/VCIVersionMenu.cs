#pragma warning disable
using System;
using System.IO;
using System.Linq;
using System.Text;
using UniGLTF;
using UniJSON;
using UnityEditor;
using UnityEngine;


namespace VCI
{
    public static class VCIVersionMenu
    {
        const string path = "Assets/VRM/VCI/Scripts/Format/VCIVersion.cs";
        const string template = @"
namespace VCI
{{
    public static partial class VCIVersion
    {{
        // this is generated by UniVCI/Increment|Decrement menu

        public const int MAJOR = {0};
        public const int MINOR = {1};

        public const string VERSION = ""{0}.{1}"";
    }}
}}
";

#if VRM_DEVELOP
        [MenuItem(VCIVersion.MENU + "/Increment")]
#endif
        static void IncrementVersion()
        {
            var source = string.Format(template, VCIVersion.MAJOR, VCIVersion.MINOR + 1);
            File.WriteAllText(path, source);
            AssetDatabase.Refresh();
        }

#if VRM_DEVELOP
        [MenuItem(VCIVersion.MENU + "/Decrement")]
#endif
        static void DecrementVersion()
        {
            var source = string.Format(template, VCIVersion.MAJOR, VCIVersion.MINOR - 1);
            File.WriteAllText(path, source);
            AssetDatabase.Refresh();
        }

        static string GetTitle(ListTreeNode<JsonValue> node)
        {
            try
            {
                var titleNode = node["title"];
                if (titleNode.IsString())
                {
                    return titleNode.GetString();
                }
            }
            catch (Exception)
            {
            }
            return "";
        }

        static void TraverseItem(ListTreeNode<JsonValue> node, JsonFormatter f, FilePath dir)
        {
            var title = GetTitle(node);
            if (string.IsNullOrEmpty(title))
            {
                Traverse(node, f, dir);
            }
            else
            {
                // ref
                f.BeginMap();
                f.Key("$ref");
                var fileName = string.Format("{0}.schema.json", title);
                f.Value(fileName);
                f.EndMap();

                // new formatter
                {
                    var subFormatter = new JsonFormatter(4);

                    subFormatter.BeginMap();
                    foreach (var _kv in node.ObjectItems())
                    {
                        subFormatter.Key(_kv.Key.GetUtf8String());
                        Traverse(_kv.Value, subFormatter, dir);
                    }
                    subFormatter.EndMap();

                    var subJson = subFormatter.ToString();
                    var path = dir.Child(fileName);
                    File.WriteAllText(path.FullPath, subJson);
                }
            }
        }

        static void Traverse(ListTreeNode<JsonValue> node, JsonFormatter f, FilePath dir)
        {
            if (node.IsArray())
            {
                f.BeginList();
                foreach (var x in node.ArrayItems())
                {
                    TraverseItem(x, f, dir);
                }
                f.EndList();
            }
            else if (node.IsMap())
            {
                f.BeginMap();
                foreach (var kv in node.ObjectItems())
                {
                    f.Key(kv.Key.GetUtf8String());
                    TraverseItem(kv.Value, f, dir);
                }
                f.EndMap();
            }
            else
            {
                f.Value(node);
            }
        }

        struct FilePath
        {
            public string FullPath
            {
                get;
                private set;
            }

            public FilePath(string path)
            {
                FullPath = Path.GetFullPath(path).Replace("\\", "/");
            }

            public void EnsureFolder()
            {
                Debug.LogFormat("EnsureFolder: {0}", FullPath);
                var splited = FullPath.Split('/');
                for (int i = 0; i < splited.Length; ++i)
                {
                    var path = String.Join("/", splited.Take(i + 1).ToArray());
                    if (!Directory.Exists(path))
                    {
                        Debug.LogFormat("CreateDirectory: {0}", path);
                        Directory.CreateDirectory(path);
                    }
                }
            }

            public FilePath Child(string name)
            {
                return new FilePath(Path.Combine(FullPath, name));
            }
        }

        static FilePath SplitAndWriteJson(ListTreeNode<JsonValue> parsed, FilePath dir, string name)
        {
            var f = new JsonFormatter(4);
            Traverse(parsed, f, dir);
            var json = f.ToString();

            var path = dir.Child(string.Format("{0}.schema.json", name));
            Debug.LogFormat("write JsonSchema: {0}", path.FullPath);
            File.WriteAllText(path.FullPath, json);
            return path;
        }

        static void ExportJsonSchema(JsonSchema schema, string name)
        {
            var f = new JsonFormatter(2);
            schema.ToJson(f);
            var json = f.ToString();

            var dir = new FilePath(Application.dataPath + "/../specification/VCI/0.0/schema");
            dir.EnsureFolder();

            var path = SplitAndWriteJson(JsonParser.Parse(json), dir, name);
        }


#if VRM_DEVELOP
        [MenuItem(VCIVersion.MENU + "/Export JsonSchema")]
#endif
        static void ExportJsonSchema()
        {
            ExportJsonSchema(JsonSchema.FromType<glTF_VCAST_vci_audio>(), "audio");
            ExportJsonSchema(JsonSchema.FromType<glTF_VCAST_vci_colliders>(), "collider");
            ExportJsonSchema(JsonSchema.FromType<glTF_VCAST_vci_embedded_script>(), "embedded_script");
            ExportJsonSchema(JsonSchema.FromType<glTF_VCAST_vci_item>(), "item");
            ExportJsonSchema(JsonSchema.FromType<glTF_VCAST_vci_joints>(), "joint");
            ExportJsonSchema(JsonSchema.FromType<glTF_VCAST_vci_material_unity>(), "material_unity");
            ExportJsonSchema(JsonSchema.FromType<glTF_VCAST_vci_meta>(), "meta");
            ExportJsonSchema(JsonSchema.FromType<glTF_VCAST_vci_rigidbody>(), "rigidbody");
        }
    }
}
